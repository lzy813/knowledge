# 一、简介

## 1、为什么会出现docker

![docker出现前后对比](C:\Users\lzy\Desktop\work\微服务\docker\图片\docker出现前后对比.png)

- 出现之前
  - 开发提交src代码，在本地可以运行，但是在运维部署服务器上环境可能导致不一致，就会发生启动不了的情况
  - 安装麻烦，比如代码所需环境很多，传统意义上保持一致需要安装大量的环境，很是繁琐
  - 扩容、缩容问题。比如现在两个服务无法满足要求，要立即扩容成四个服务器，传统方式必定无法满足
- 出现之后
  - 将所有的源码、配置、环境等直接打包成一个镜像文件，然后放置到docker中
  - 无需管代码所需环境，只需要一步生成整个文件运行，运行扩容等都方便
- 类推举例
  - 以前搬家，都是把家具、衣服啥的都打包带到新房子里，中途肯定会导致很多东西丢失或者新房子装不下啥的
  - 现在就直接搬楼，把整个房子搬走，这样就不用一点点打包东西搬运，然后重新整理房间啥的，也不怕东西丢失或装不下




## 2、docker优点

- 针对上述问题，docker给了一个标准解决方案——**系统平滑移植，容器虚拟化技术**
- **docker打破了过去程序即应用的观念。通过镜像(images)将作业系统核心除外，运作应用程序所需要的系统环境，由下而上打包，达到应用程序跨平台间的无缝接轨运作**




## 3、docker理念

![docker理念](C:\Users\lzy\Desktop\work\微服务\docker\图片\docker理念.png)

- 跟linux虚拟机差不多，在VMware上面运行centos7.iso镜像，就可以保证环境全部迁移
- **类比过来，docker就是就是把软件代码以及运行环境啥的全部打包成镜像文件，然后交给docker运行，就可以实现一步启动项目**
- 在不同的docker上运行同一个镜像，还是能达到相同的效果



## 4、docker是什么

- **docker是基于go语言实现的云开源项目**
- docker的主要目标：通过对应组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个web应用或数据库应用等）及其与逆行环境能够做到——**一次镜像，处处运行**
- **Linux容器技术的出现就解决了这样一个问题，而docker就是在它的基础上发展过来的**
- 将应用打成镜像，通过镜像成为运行在docker容器上的实例。而docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。
- **只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作**



## 5、总结

- **解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术**



## 6、容器和传统虚拟机比较

### 6.1 虚拟机

- **虚拟机就是带环境安装的一种解决方案**
- 它可以在一种操作系统里面运行另一种操作系统，比如在win10系统里面运行Linux的系统Centos7.
- **应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删除，对其他部分毫无影响。**
- 这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变

![传统虚拟机](C:\Users\lzy\Desktop\work\微服务\docker\图片\传统虚拟机.png)

- 缺点：
  - 资源占用多
  - 冗余步骤多
  - 启动慢



### 6.2 容器

- Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性
- **Linux容器不是模拟一个完整的操作系统而是对进程进行隔离**。有了容器，就可以将软件运行所需要的所有资源打包到一个隔离的容器中。**容器和虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需要的库资源和设置**。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行

![容器](C:\Users\lzy\Desktop\work\微服务\docker\图片\容器.png)



### 6.3 比较总结

- 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程
- 容器内的应用程序直接运行于宿主的内核，**容器内没有自己的内核且没有进行硬件虚拟**。因此容器要比传统虚拟机更为轻便
- 每个容器之间互相隔离，每个容器都有自己的文件系统，容器之间进程不会互相影响，能区分计算资源



## 7、docker解决哪些问题

- 优势
  - **更快速的应用支付和部署**
    - 传统的应用开发完成后，需要提供一堆安装程序和配置文档说明，安装部署后需要根据配置文档进行复杂的配置才能正常运行。docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间
  - **更快捷的升级和扩缩容**
    - 随着微服务架构和docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭积木的方式，每个docker容器将变成一块积木，应用的升级就会变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天极变成分钟级甚至秒级
  - **更简单的系统运维**
    - 应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的bug。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复
  - **更搞笑的计算资源利用**
    - **docker是内核级虚拟化**，不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，大大提升物理服务器的CPU和内存的利用率





# 二、入门

## 1、三要素

### 1.1 镜像

- Docker镜像（Image）就是一个**只读**的模板。镜像可以用来创建Docker容器，**一个镜像可以创建很多容器**
- **docker镜像文件类似于Java的类模板，而docker容器实例类似于Java中new出来的实例对象**



### 1.2 容器

- 从面向对象角度
  - Docker利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，**容器是用镜像创建的运行实例**。就像是Java中的类和实例对象一样，镜像是静态的定义，容器时镜像运行时的实体。容器位镜像提供了一个标准的和隔离的运行环境，它可被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台
- 从镜像容器角度
  - **可以把容器看作是一个简易版的Linxu环境**（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序



### 1.3 仓库

- **仓库（Repository）是集中存放镜像文件的场所**
- 类似于
  - maven仓库：存放各种jar包的地方
  - github仓库：存放各种git项目的地方
  - docker hub：docker公司提供的官方仓库，存放各种镜像模板的地方
- 仓库分为公开仓库（Public）和私有仓库（Private）两种形式
- **最大的公开仓库是Docker hub**，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云、网易云等



### 1.4 总结

- docker本身是一个容器运行载体或称之为管理引擎。把应用程序和配置依赖打包好成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成docker容器实例
- image文件可以看作是容器的模板。docker根据image文件生成容器的实例。同一个iamge文件，可以生成多个同时运行的容器实例
- 镜像文件
  - 把应用程序和配置依赖打包好成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件，镜像文件可以运行成一个服务实例
- 容器实例
  - 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的实例
- 仓库
  - 就是放一堆镜像文件的地方，我们可以把镜像文件发布到仓库中，需要的时候再从仓库中拉出来就行

![三要素](C:\Users\lzy\Desktop\work\微服务\docker\图片\三要素.png)



## 2、docker运行图解（入门版）

![docker工作原理](C:\Users\lzy\Desktop\work\微服务\docker\图片\docker工作原理.png)

- docker是一个Client-Server结构的系统
- **docker守护进程运行在主机上，然后通过Socket连接客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器**
- 客户端发送请求，守护进程接收，如果本机有对应的镜像文件，就直接操作，没有就从远程上拉取





